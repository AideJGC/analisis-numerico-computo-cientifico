# -*- coding: utf-8 -*-
"""Entrega_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hT-0vFxslpk8cxvubJQqGcPp1nBO0_lg

# **PROYECTO FINAL DE MÉTODOS NUMÉRICOS Y OPTIMIZACIÓN**

### El problema de Santa Viajero

|             NOMBRE             | USUARIO GITHUB |
|:------------------------------:|:--------------:|
|     Joel Jaramillo Pacheco     |  joelitam2021  |
|    Miguel Ángel Reyes Retana   |  rrmiguel-2401 |
| Mónica Altagracia García López |   mogarcia62   |
|  Rodrigo Ivan Juárez Jaramillo |     ro-juja    |

De una competencia realizada en [Kaggle: Traveling Santa Problem](https://www.kaggle.com/c/traveling-santa-problem/data?select=santa_cities.csv), 

El reto de esta competencia es encontrar la solución a un problema de optimización muy importante: Santa Claus necesita de nuestra ayuda para elegir la ruta que toma a la hora de entregar regalos en todo el mundo. El gran reto en este problema es encontrar caminos que minimicen las distancias a través de un conjunto de chimeneas. 

Como nos comentó el profesor Erick Palacios, el problema de Santa Claus es muy parecido al problema del vendedor viajero. Desde esa perspectiva como equipo, nos pareció una buena idea para abordar el problema de optimización. 

Para desarrollar el problema contamos con una base de datos que contiene diferentes puntos, en total 150,000 diferentes puntos que representan las diferentes chimeneas por las cuales tiene que aterrizar el señor Claus.

Para desarrollar el código, nos basamos fuertemente en el código implementado en el siguiente [notebook](https://colab.research.google.com/drive/1LVEwi94vlyyL19NWMc_oePVhdGkQAlG3#scrollTo=pze9ac-PkHXw), de un autor desconocido.
"""

!pip install geopandas
!pip install geopy

import numpy as np
import pandas as pd
import geopandas
import matplotlib.pyplot as plt
import cvxpy as cp
import matplotlib.pyplot as plt
import numpy as np
import random



from scipy.spatial import distance_matrix
from scipy.spatial.distance import pdist, squareform
from geopy import distance

random.seed(500)

"""Las chimeneas están repartidas en las siguientes ciudades."""

cities = pd.read_csv('santa_cities.csv')

cities.info()

gdf = geopandas.GeoDataFrame(
    cities, geometry=geopandas.points_from_xy(cities.x, cities.y))

cities

fig=plt.figure()
ax=fig.add_axes([0,0,1,1])
ax.scatter(cities.x, cities.y, color='firebrick', s=.01)
plt.show()

"""Sin embargo, como es bien sabido, los niños que se portan bien son los favoritos de Santa Claus, por lo cual, Santa, al ver que tiene tantos niños que visitar, decide sacar la Famosa Santa's list. En dicha Lista, Santa se ha encargado de calificar el comportamiento de todos los niños del 1 al 10.

Para simular las calificaciones de la lista de Santa, suponemos que los niños tienen en general un comportamiento regular, es decir, de 5. Pocos son los niños que sacan 10 y pocos son los niños que se portan demasiado mal. A cada chimenea le agregaremos una calificación y Santa escogerá primero a los niños con 9 o más de calificación en comportamiento y así sucesivamente de forma descendente.

Tomando como referencia al notebook de [mTSP_en.ipynb](https://colab.research.google.com/github/cvxpy/cvxpy/blob/master/examples/notebooks/WWW/mTSP_en.ipynb#scrollTo=KVdBD7b1PDw6)

Intentaremos replicar el ejemplo de un Vendedor Viajero: Example for a single Traveling Salesman

En este primer data frame, simularemos las calificaciones de comportamiento de la lista de Santa de las chimeneas de los niños.
"""

np.random.seed(12345)
mu, sigma = 5, 1.12
s = np.random.normal(mu, sigma, 150000)
df=pd.DataFrame(s)
df = df.rename(columns = {0: 'behavior'}, inplace = False)

df.describe()

"""Tomando en cuenta los scores de behavior, Santa Claus quiere darle sus regalos a los niños que tengan un behavior mayor a 9"""

cities_behavior=pd.concat([cities, df], axis=1)

cities_behavior_9=cities_behavior[cities_behavior['behavior']>9]

cities_behavior_9.info()

"""Las chimeneas que Santa va a visitar están ubicadas en el siguiente mapa:"""

fig=plt.figure()
ax=fig.add_axes([0,0,1,1])
ax.scatter(cities_behavior_9.x, cities_behavior_9.y, color='firebrick', s=4)
plt.show()

#create n x d matrix (n=observations, d=dimensions)
A=cities_behavior_9[['x', 'y']].to_numpy().T

df=cities_behavior_9[['x','y']]

#Creamos matriz de distancias:
C=pd.DataFrame(distance_matrix(df.values, df.values), index=df.index, columns=df.index)

"""Esta es la matriz de distancias:"""

np.set_printoptions(precision=3, suppress=True)
C

"""Planteamiento del problema"""

X = cp.Variable(C.shape, boolean=True)
n = len(C)
u = cp.Variable(n, integer=True)
ones = np.ones((n,1))

objective = cp.Minimize(cp.sum(cp.multiply(C, X)))

constraints = []
constraints += [X @ ones == ones]
constraints += [X.T @ ones == ones]
constraints += [cp.diag(X) == 0]
constraints += [u[1:] >= 2]
constraints += [u[1:] <= n]
constraints += [u[0] == 1]

"""$u_i$ , $u_j$ son restricciones para la eliminación de subrutas"""

for i in range(1, n):
    for j in range(1, n):
        if i != j:
            constraints += [ u[i] - u[j] + 1  <= (n - 1) * (1 - X[i, j]) ]

prob = cp.Problem(objective, constraints)

print(round( prob.solve(verbose=False), 2))

"""De acuerdo con el algoritmo de **cvxpy** la ruta óptima para Santa está dada por la siguiente trayectoria, en donde el nodo $0$ es el punto origen de la ruta, el cual representa al Polo Norte. Y la distancia mínima de la trayectoria óptima para recorrer las ciudades y repartir los regalos es de 74.6 km"""

#Transformamos la solución a un camino
X_sol = np.argwhere(X.value==1)
orden = X_sol[0].tolist()

for i in range(1, n):
    row = orden[-1]
    orden.append(X_sol[row,1])

#Mostramos el camino óptimo:
print('La ruta óptima de Santa está dada por:\n')
print( ' => '.join(map(str, orden)))

#Obtenemos coordenadas X Y:
xy_cords=np.array(cities_behavior_9[['x', 'y']].values.tolist())

#Graficamos los puntos:
fig, ax = plt.subplots(figsize=(14,7))

for i in range(n):
    ax.annotate(str(i), xy=(xy_cords[i,0], xy_cords[i,1]+0.1))
    
ax.scatter(xy_cords[:,0],xy_cords[:,1],color='firebrick')
ax.set_title('Ruta óptima de Santa')
ax.plot(xy_cords[orden,0], xy_cords[orden,1],color='firebrick')

"""El problema del agente viajero tiene una complejidad computacional, pues el tiempo de ejecución para cualquier algoritmo que resuelva este problema aumenta de forma exponencial con respecto al número de ciudades. Aunque es costoso, el algoritmo implementado a través de **cvxpy** arroja la ruta óptima para el problema de Santa. Para una ruta de 31 puntos, tardó en correr aproximadamente 10 minutos.

A continuación implementaremos otro algoritmo con el paqute mlrose para compararlo con **cvxpy**
"""

!pip install mlrose
!pip install six

import six
import sys
sys.modules['sklearn.externals.six'] = six
import mlrose

#Creamos lista de ciudades
coords_list=cities_behavior_9[['x', 'y']].values.tolist()

# Define optimization problem object
problem_fit = mlrose.TSPOpt(length = len(coords_list), coords = coords_list, maximize = False)

# Solve using genetic algorithm
best_state, best_fitness = mlrose.genetic_alg(problem_fit, mutation_prob = 0.2, max_attempts = 1000, random_state = 2)

print(best_state)

"""La implementación del algoritmo mlrose arroja una trayectoria más larga (131.6 km) en comparación con **cvxpy**. Para mejorar el desempeño de **mlrose** hay que subir el número de max_attempts, pero por limitaciones de hardware no nos fue posible realizarlo."""

print(round( best_fitness, 2))

orden=best_state.tolist()

#Obtenemos coordenadas X Y:
xy_cords=np.array(cities_behavior_9[['x', 'y']].values.tolist())

#Graficamos los puntos:
fig, ax = plt.subplots(figsize=(14,7))

for i in range(n):
    ax.annotate(str(i), xy=(xy_cords[i,0], xy_cords[i,1]+0.1))
    
ax.scatter(xy_cords[:,0],xy_cords[:,1],color='firebrick')
ax.set_title('Ruta óptima de Santa')
ax.plot(xy_cords[orden,0], xy_cords[orden,1],color='firebrick')

"""El algoritmo de **mlrose** es más eficiente en términos computacionales,  pero es menos exacto para calcular la ruta óptima. Este algoritmo escoge de forma aleatoria el inicio de la ruta y realiza iteraciones para encontrar la ruta óptima. El desempeño depende del nodo de inicio, como mencionamos, escogido de forma aleatoria. Al incrementar el número de observaciones no nos está entregando un mejor resultado.

Referencias:

[Solving Travelling Salesperson Problems with Python- How to use randomized optimization algorithms to solve travelling salesperson problems with Python mlrose package](https://towardsdatascience.com/solving-travelling-salesperson-problems-with-python-5de7e883d847)

[Hayes, G. (2019). mlrose: Machine Learning, Randomized Optimization and SEarch package for Python.Accessed: 01-12-2021](https://github.com/gkhayes/mlrose)

[El problema del agente viajero: un recorrido sobre su historia, sus aplicaciones y problema relacionados. Un encuentro discreto, Edgar Possani](https://www.itam.mx/sites/default/files/u444/platica_possani.pdf)
"""